{"ast":null,"code":"/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\n\n/* eslint-env node */\n'use strict';\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\r\n * Extract browser version out of the provided user agent string.\r\n *\r\n * @param {!string} uastring userAgent string.\r\n * @param {!string} expr Regular expression used as match criteria.\r\n * @param {!number} pos position in the version string to be returned.\r\n * @return {!number} browser version.\r\n */\n\nexport function extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n} // Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\n\nexport function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n\n  proto.addEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n\n    const wrappedCallback = e => {\n      const modifiedEvent = wrapper(e);\n\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n\n    this._eventMap = this._eventMap || {};\n\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = new Map();\n    }\n\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n  };\n\n  const nativeRemoveEventListener = proto.removeEventListener;\n\n  proto.removeEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n\n    this._eventMap[eventNameToWrap].delete(cb);\n\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n\n      if (cb) {\n        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  });\n}\nexport function disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n\n  logDisabled_ = bool;\n  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\n}\n/**\r\n * Disable or enable deprecation warnings\r\n * @param {!boolean} bool set to true to disable warnings.\r\n */\n\nexport function disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\nexport function log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n/**\r\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\r\n */\n\nexport function deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\n}\n/**\r\n * Browser detector.\r\n *\r\n * @return {object} result containing browser and version\r\n *     properties.\r\n */\n\nexport function detectBrowser(window) {\n  // Returned result object.\n  const result = {\n    browser: null,\n    version: null\n  }; // Fail early if it's not a browser\n\n  if (typeof window === 'undefined' || !window.navigator) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n\n  const {\n    navigator\n  } = window;\n\n  if (navigator.mozGetUserMedia) {\n    // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n    // Edge.\n    result.browser = 'edge';\n    result.version = extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2);\n  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n    // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;\n  } else {\n    // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  return result;\n}\n/**\r\n * Checks if something is an object.\r\n *\r\n * @param {*} val The something you want to check.\r\n * @return true if val is an object, false otherwise.\r\n */\n\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n/**\r\n * Remove all empty objects and undefined values\r\n * from a nested object -- an enhanced and vanilla version\r\n * of Lodash's `compact`.\r\n */\n\n\nexport function compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n\n  return Object.keys(data).reduce(function (accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n\n    return Object.assign(accumulator, {\n      [key]: value\n    });\n  }, {});\n}\n/* iterates the stats graph recursively. */\n\nexport function walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n/* filter getStats for a sender/receiver track. */\n\nexport function filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n\n  if (track === null) {\n    return filteredResult;\n  }\n\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' && value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}","map":{"version":3,"sources":["C:/Users/stefan/Desktop/ISA-projekat/ISA-projekat/ISA-front/node_modules/webrtc-adapter/src/js/utils.js"],"names":["logDisabled_","deprecationWarnings_","extractVersion","uastring","expr","pos","match","length","parseInt","wrapPeerConnectionEvent","window","eventNameToWrap","wrapper","RTCPeerConnection","proto","prototype","nativeAddEventListener","addEventListener","nativeEventName","cb","apply","arguments","wrappedCallback","e","modifiedEvent","handleEvent","_eventMap","Map","set","nativeRemoveEventListener","removeEventListener","has","unwrappedCb","get","delete","size","Object","keys","defineProperty","enumerable","configurable","disableLog","bool","Error","disableWarnings","log","console","deprecated","oldMethod","newMethod","warn","detectBrowser","result","browser","version","navigator","mozGetUserMedia","userAgent","webkitGetUserMedia","isSecureContext","webkitRTCPeerConnection","RTCIceGatherer","mediaDevices","supportsUnifiedPlan","RTCRtpTransceiver","isObject","val","toString","call","compactObject","data","reduce","accumulator","key","isObj","value","isEmptyObject","undefined","assign","walkStats","stats","base","resultSet","id","forEach","name","endsWith","filterStats","track","outbound","streamStatsType","filteredResult","trackStats","type","trackIdentifier","push","trackStat","trackId"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AACC;AACD;;AAEA,IAAIA,YAAY,GAAG,IAAnB;AACA,IAAIC,oBAAoB,GAAG,IAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,QAAxB,EAAkCC,IAAlC,EAAwCC,GAAxC,EAA6C;AAClD,QAAMC,KAAK,GAAGH,QAAQ,CAACG,KAAT,CAAeF,IAAf,CAAd;AACA,SAAOE,KAAK,IAAIA,KAAK,CAACC,MAAN,IAAgBF,GAAzB,IAAgCG,QAAQ,CAACF,KAAK,CAACD,GAAD,CAAN,EAAa,EAAb,CAA/C;AACD,C,CAED;AACA;AACA;;AACA,OAAO,SAASI,uBAAT,CAAiCC,MAAjC,EAAyCC,eAAzC,EAA0DC,OAA1D,EAAmE;AACxE,MAAI,CAACF,MAAM,CAACG,iBAAZ,EAA+B;AAC7B;AACD;;AACD,QAAMC,KAAK,GAAGJ,MAAM,CAACG,iBAAP,CAAyBE,SAAvC;AACA,QAAMC,sBAAsB,GAAGF,KAAK,CAACG,gBAArC;;AACAH,EAAAA,KAAK,CAACG,gBAAN,GAAyB,UAASC,eAAT,EAA0BC,EAA1B,EAA8B;AACrD,QAAID,eAAe,KAAKP,eAAxB,EAAyC;AACvC,aAAOK,sBAAsB,CAACI,KAAvB,CAA6B,IAA7B,EAAmCC,SAAnC,CAAP;AACD;;AACD,UAAMC,eAAe,GAAIC,CAAD,IAAO;AAC7B,YAAMC,aAAa,GAAGZ,OAAO,CAACW,CAAD,CAA7B;;AACA,UAAIC,aAAJ,EAAmB;AACjB,YAAIL,EAAE,CAACM,WAAP,EAAoB;AAClBN,UAAAA,EAAE,CAACM,WAAH,CAAeD,aAAf;AACD,SAFD,MAEO;AACLL,UAAAA,EAAE,CAACK,aAAD,CAAF;AACD;AACF;AACF,KATD;;AAUA,SAAKE,SAAL,GAAiB,KAAKA,SAAL,IAAkB,EAAnC;;AACA,QAAI,CAAC,KAAKA,SAAL,CAAef,eAAf,CAAL,EAAsC;AACpC,WAAKe,SAAL,CAAef,eAAf,IAAkC,IAAIgB,GAAJ,EAAlC;AACD;;AACD,SAAKD,SAAL,CAAef,eAAf,EAAgCiB,GAAhC,CAAoCT,EAApC,EAAwCG,eAAxC;;AACA,WAAON,sBAAsB,CAACI,KAAvB,CAA6B,IAA7B,EAAmC,CAACF,eAAD,EACxCI,eADwC,CAAnC,CAAP;AAED,GArBD;;AAuBA,QAAMO,yBAAyB,GAAGf,KAAK,CAACgB,mBAAxC;;AACAhB,EAAAA,KAAK,CAACgB,mBAAN,GAA4B,UAASZ,eAAT,EAA0BC,EAA1B,EAA8B;AACxD,QAAID,eAAe,KAAKP,eAApB,IAAuC,CAAC,KAAKe,SAA7C,IACG,CAAC,KAAKA,SAAL,CAAef,eAAf,CADR,EACyC;AACvC,aAAOkB,yBAAyB,CAACT,KAA1B,CAAgC,IAAhC,EAAsCC,SAAtC,CAAP;AACD;;AACD,QAAI,CAAC,KAAKK,SAAL,CAAef,eAAf,EAAgCoB,GAAhC,CAAoCZ,EAApC,CAAL,EAA8C;AAC5C,aAAOU,yBAAyB,CAACT,KAA1B,CAAgC,IAAhC,EAAsCC,SAAtC,CAAP;AACD;;AACD,UAAMW,WAAW,GAAG,KAAKN,SAAL,CAAef,eAAf,EAAgCsB,GAAhC,CAAoCd,EAApC,CAApB;;AACA,SAAKO,SAAL,CAAef,eAAf,EAAgCuB,MAAhC,CAAuCf,EAAvC;;AACA,QAAI,KAAKO,SAAL,CAAef,eAAf,EAAgCwB,IAAhC,KAAyC,CAA7C,EAAgD;AAC9C,aAAO,KAAKT,SAAL,CAAef,eAAf,CAAP;AACD;;AACD,QAAIyB,MAAM,CAACC,IAAP,CAAY,KAAKX,SAAjB,EAA4BnB,MAA5B,KAAuC,CAA3C,EAA8C;AAC5C,aAAO,KAAKmB,SAAZ;AACD;;AACD,WAAOG,yBAAyB,CAACT,KAA1B,CAAgC,IAAhC,EAAsC,CAACF,eAAD,EAC3Cc,WAD2C,CAAtC,CAAP;AAED,GAlBD;;AAoBAI,EAAAA,MAAM,CAACE,cAAP,CAAsBxB,KAAtB,EAA6B,OAAOH,eAApC,EAAqD;AACnDsB,IAAAA,GAAG,GAAG;AACJ,aAAO,KAAK,QAAQtB,eAAb,CAAP;AACD,KAHkD;;AAInDiB,IAAAA,GAAG,CAACT,EAAD,EAAK;AACN,UAAI,KAAK,QAAQR,eAAb,CAAJ,EAAmC;AACjC,aAAKmB,mBAAL,CAAyBnB,eAAzB,EACI,KAAK,QAAQA,eAAb,CADJ;AAEA,eAAO,KAAK,QAAQA,eAAb,CAAP;AACD;;AACD,UAAIQ,EAAJ,EAAQ;AACN,aAAKF,gBAAL,CAAsBN,eAAtB,EACI,KAAK,QAAQA,eAAb,IAAgCQ,EADpC;AAED;AACF,KAdkD;;AAenDoB,IAAAA,UAAU,EAAE,IAfuC;AAgBnDC,IAAAA,YAAY,EAAE;AAhBqC,GAArD;AAkBD;AAED,OAAO,SAASC,UAAT,CAAoBC,IAApB,EAA0B;AAC/B,MAAI,OAAOA,IAAP,KAAgB,SAApB,EAA+B;AAC7B,WAAO,IAAIC,KAAJ,CAAU,oBAAoB,OAAOD,IAA3B,GACb,yBADG,CAAP;AAED;;AACD1C,EAAAA,YAAY,GAAG0C,IAAf;AACA,SAAQA,IAAD,GAAS,6BAAT,GACH,4BADJ;AAED;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASE,eAAT,CAAyBF,IAAzB,EAA+B;AACpC,MAAI,OAAOA,IAAP,KAAgB,SAApB,EAA+B;AAC7B,WAAO,IAAIC,KAAJ,CAAU,oBAAoB,OAAOD,IAA3B,GACb,yBADG,CAAP;AAED;;AACDzC,EAAAA,oBAAoB,GAAG,CAACyC,IAAxB;AACA,SAAO,sCAAsCA,IAAI,GAAG,UAAH,GAAgB,SAA1D,CAAP;AACD;AAED,OAAO,SAASG,GAAT,GAAe;AACpB,MAAI,OAAOnC,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,QAAIV,YAAJ,EAAkB;AAChB;AACD;;AACD,QAAI,OAAO8C,OAAP,KAAmB,WAAnB,IAAkC,OAAOA,OAAO,CAACD,GAAf,KAAuB,UAA7D,EAAyE;AACvEC,MAAAA,OAAO,CAACD,GAAR,CAAYzB,KAAZ,CAAkB0B,OAAlB,EAA2BzB,SAA3B;AACD;AACF;AACF;AAED;AACA;AACA;;AACA,OAAO,SAAS0B,UAAT,CAAoBC,SAApB,EAA+BC,SAA/B,EAA0C;AAC/C,MAAI,CAAChD,oBAAL,EAA2B;AACzB;AACD;;AACD6C,EAAAA,OAAO,CAACI,IAAR,CAAaF,SAAS,GAAG,6BAAZ,GAA4CC,SAA5C,GACT,WADJ;AAED;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,aAAT,CAAuBzC,MAAvB,EAA+B;AACpC;AACA,QAAM0C,MAAM,GAAG;AAACC,IAAAA,OAAO,EAAE,IAAV;AAAgBC,IAAAA,OAAO,EAAE;AAAzB,GAAf,CAFoC,CAIpC;;AACA,MAAI,OAAO5C,MAAP,KAAkB,WAAlB,IAAiC,CAACA,MAAM,CAAC6C,SAA7C,EAAwD;AACtDH,IAAAA,MAAM,CAACC,OAAP,GAAiB,gBAAjB;AACA,WAAOD,MAAP;AACD;;AAED,QAAM;AAACG,IAAAA;AAAD,MAAc7C,MAApB;;AAEA,MAAI6C,SAAS,CAACC,eAAd,EAA+B;AAAE;AAC/BJ,IAAAA,MAAM,CAACC,OAAP,GAAiB,SAAjB;AACAD,IAAAA,MAAM,CAACE,OAAP,GAAiBpD,cAAc,CAACqD,SAAS,CAACE,SAAX,EAC3B,kBAD2B,EACP,CADO,CAA/B;AAED,GAJD,MAIO,IAAIF,SAAS,CAACG,kBAAV,IACNhD,MAAM,CAACiD,eAAP,KAA2B,KAA3B,IAAoCjD,MAAM,CAACkD,uBAA3C,IACA,CAAClD,MAAM,CAACmD,cAFN,EAEuB;AAC5B;AACA;AACA;AACA;AACAT,IAAAA,MAAM,CAACC,OAAP,GAAiB,QAAjB;AACAD,IAAAA,MAAM,CAACE,OAAP,GAAiBpD,cAAc,CAACqD,SAAS,CAACE,SAAX,EAC3B,uBAD2B,EACF,CADE,CAA/B;AAED,GAVM,MAUA,IAAIF,SAAS,CAACO,YAAV,IACPP,SAAS,CAACE,SAAV,CAAoBnD,KAApB,CAA0B,oBAA1B,CADG,EAC8C;AAAE;AACrD8C,IAAAA,MAAM,CAACC,OAAP,GAAiB,MAAjB;AACAD,IAAAA,MAAM,CAACE,OAAP,GAAiBpD,cAAc,CAACqD,SAAS,CAACE,SAAX,EAC3B,oBAD2B,EACL,CADK,CAA/B;AAED,GALM,MAKA,IAAI/C,MAAM,CAACG,iBAAP,IACP0C,SAAS,CAACE,SAAV,CAAoBnD,KAApB,CAA0B,sBAA1B,CADG,EACgD;AAAE;AACvD8C,IAAAA,MAAM,CAACC,OAAP,GAAiB,QAAjB;AACAD,IAAAA,MAAM,CAACE,OAAP,GAAiBpD,cAAc,CAACqD,SAAS,CAACE,SAAX,EAC3B,sBAD2B,EACH,CADG,CAA/B;AAEAL,IAAAA,MAAM,CAACW,mBAAP,GAA6BrD,MAAM,CAACsD,iBAAP,IACzB,sBAAsBtD,MAAM,CAACsD,iBAAP,CAAyBjD,SADnD;AAED,GAPM,MAOA;AAAE;AACPqC,IAAAA,MAAM,CAACC,OAAP,GAAiB,0BAAjB;AACA,WAAOD,MAAP;AACD;;AAED,SAAOA,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,SAASa,QAAT,CAAkBC,GAAlB,EAAuB;AACrB,SAAO9B,MAAM,CAACrB,SAAP,CAAiBoD,QAAjB,CAA0BC,IAA1B,CAA+BF,GAA/B,MAAwC,iBAA/C;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASG,aAAT,CAAuBC,IAAvB,EAA6B;AAClC,MAAI,CAACL,QAAQ,CAACK,IAAD,CAAb,EAAqB;AACnB,WAAOA,IAAP;AACD;;AAED,SAAOlC,MAAM,CAACC,IAAP,CAAYiC,IAAZ,EAAkBC,MAAlB,CAAyB,UAASC,WAAT,EAAsBC,GAAtB,EAA2B;AACzD,UAAMC,KAAK,GAAGT,QAAQ,CAACK,IAAI,CAACG,GAAD,CAAL,CAAtB;AACA,UAAME,KAAK,GAAGD,KAAK,GAAGL,aAAa,CAACC,IAAI,CAACG,GAAD,CAAL,CAAhB,GAA8BH,IAAI,CAACG,GAAD,CAArD;AACA,UAAMG,aAAa,GAAGF,KAAK,IAAI,CAACtC,MAAM,CAACC,IAAP,CAAYsC,KAAZ,EAAmBpE,MAAnD;;AACA,QAAIoE,KAAK,KAAKE,SAAV,IAAuBD,aAA3B,EAA0C;AACxC,aAAOJ,WAAP;AACD;;AACD,WAAOpC,MAAM,CAAC0C,MAAP,CAAcN,WAAd,EAA2B;AAAC,OAACC,GAAD,GAAOE;AAAR,KAA3B,CAAP;AACD,GARM,EAQJ,EARI,CAAP;AASD;AAED;;AACA,OAAO,SAASI,SAAT,CAAmBC,KAAnB,EAA0BC,IAA1B,EAAgCC,SAAhC,EAA2C;AAChD,MAAI,CAACD,IAAD,IAASC,SAAS,CAACnD,GAAV,CAAckD,IAAI,CAACE,EAAnB,CAAb,EAAqC;AACnC;AACD;;AACDD,EAAAA,SAAS,CAACtD,GAAV,CAAcqD,IAAI,CAACE,EAAnB,EAAuBF,IAAvB;AACA7C,EAAAA,MAAM,CAACC,IAAP,CAAY4C,IAAZ,EAAkBG,OAAlB,CAA0BC,IAAI,IAAI;AAChC,QAAIA,IAAI,CAACC,QAAL,CAAc,IAAd,CAAJ,EAAyB;AACvBP,MAAAA,SAAS,CAACC,KAAD,EAAQA,KAAK,CAAC/C,GAAN,CAAUgD,IAAI,CAACI,IAAD,CAAd,CAAR,EAA+BH,SAA/B,CAAT;AACD,KAFD,MAEO,IAAIG,IAAI,CAACC,QAAL,CAAc,KAAd,CAAJ,EAA0B;AAC/BL,MAAAA,IAAI,CAACI,IAAD,CAAJ,CAAWD,OAAX,CAAmBD,EAAE,IAAI;AACvBJ,QAAAA,SAAS,CAACC,KAAD,EAAQA,KAAK,CAAC/C,GAAN,CAAUkD,EAAV,CAAR,EAAuBD,SAAvB,CAAT;AACD,OAFD;AAGD;AACF,GARD;AASD;AAED;;AACA,OAAO,SAASK,WAAT,CAAqBnC,MAArB,EAA6BoC,KAA7B,EAAoCC,QAApC,EAA8C;AACnD,QAAMC,eAAe,GAAGD,QAAQ,GAAG,cAAH,GAAoB,aAApD;AACA,QAAME,cAAc,GAAG,IAAIhE,GAAJ,EAAvB;;AACA,MAAI6D,KAAK,KAAK,IAAd,EAAoB;AAClB,WAAOG,cAAP;AACD;;AACD,QAAMC,UAAU,GAAG,EAAnB;AACAxC,EAAAA,MAAM,CAACgC,OAAP,CAAeT,KAAK,IAAI;AACtB,QAAIA,KAAK,CAACkB,IAAN,KAAe,OAAf,IACAlB,KAAK,CAACmB,eAAN,KAA0BN,KAAK,CAACL,EADpC,EACwC;AACtCS,MAAAA,UAAU,CAACG,IAAX,CAAgBpB,KAAhB;AACD;AACF,GALD;AAMAiB,EAAAA,UAAU,CAACR,OAAX,CAAmBY,SAAS,IAAI;AAC9B5C,IAAAA,MAAM,CAACgC,OAAP,CAAeJ,KAAK,IAAI;AACtB,UAAIA,KAAK,CAACa,IAAN,KAAeH,eAAf,IAAkCV,KAAK,CAACiB,OAAN,KAAkBD,SAAS,CAACb,EAAlE,EAAsE;AACpEJ,QAAAA,SAAS,CAAC3B,MAAD,EAAS4B,KAAT,EAAgBW,cAAhB,CAAT;AACD;AACF,KAJD;AAKD,GAND;AAOA,SAAOA,cAAP;AACD","sourcesContent":["/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n /* eslint-env node */\r\n'use strict';\r\n\r\nlet logDisabled_ = true;\r\nlet deprecationWarnings_ = true;\r\n\r\n/**\r\n * Extract browser version out of the provided user agent string.\r\n *\r\n * @param {!string} uastring userAgent string.\r\n * @param {!string} expr Regular expression used as match criteria.\r\n * @param {!number} pos position in the version string to be returned.\r\n * @return {!number} browser version.\r\n */\r\nexport function extractVersion(uastring, expr, pos) {\r\n  const match = uastring.match(expr);\r\n  return match && match.length >= pos && parseInt(match[pos], 10);\r\n}\r\n\r\n// Wraps the peerconnection event eventNameToWrap in a function\r\n// which returns the modified event object (or false to prevent\r\n// the event).\r\nexport function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  const proto = window.RTCPeerConnection.prototype;\r\n  const nativeAddEventListener = proto.addEventListener;\r\n  proto.addEventListener = function(nativeEventName, cb) {\r\n    if (nativeEventName !== eventNameToWrap) {\r\n      return nativeAddEventListener.apply(this, arguments);\r\n    }\r\n    const wrappedCallback = (e) => {\r\n      const modifiedEvent = wrapper(e);\r\n      if (modifiedEvent) {\r\n        if (cb.handleEvent) {\r\n          cb.handleEvent(modifiedEvent);\r\n        } else {\r\n          cb(modifiedEvent);\r\n        }\r\n      }\r\n    };\r\n    this._eventMap = this._eventMap || {};\r\n    if (!this._eventMap[eventNameToWrap]) {\r\n      this._eventMap[eventNameToWrap] = new Map();\r\n    }\r\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\r\n    return nativeAddEventListener.apply(this, [nativeEventName,\r\n      wrappedCallback]);\r\n  };\r\n\r\n  const nativeRemoveEventListener = proto.removeEventListener;\r\n  proto.removeEventListener = function(nativeEventName, cb) {\r\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\r\n        || !this._eventMap[eventNameToWrap]) {\r\n      return nativeRemoveEventListener.apply(this, arguments);\r\n    }\r\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\r\n      return nativeRemoveEventListener.apply(this, arguments);\r\n    }\r\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\r\n    this._eventMap[eventNameToWrap].delete(cb);\r\n    if (this._eventMap[eventNameToWrap].size === 0) {\r\n      delete this._eventMap[eventNameToWrap];\r\n    }\r\n    if (Object.keys(this._eventMap).length === 0) {\r\n      delete this._eventMap;\r\n    }\r\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\r\n      unwrappedCb]);\r\n  };\r\n\r\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\r\n    get() {\r\n      return this['_on' + eventNameToWrap];\r\n    },\r\n    set(cb) {\r\n      if (this['_on' + eventNameToWrap]) {\r\n        this.removeEventListener(eventNameToWrap,\r\n            this['_on' + eventNameToWrap]);\r\n        delete this['_on' + eventNameToWrap];\r\n      }\r\n      if (cb) {\r\n        this.addEventListener(eventNameToWrap,\r\n            this['_on' + eventNameToWrap] = cb);\r\n      }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  });\r\n}\r\n\r\nexport function disableLog(bool) {\r\n  if (typeof bool !== 'boolean') {\r\n    return new Error('Argument type: ' + typeof bool +\r\n        '. Please use a boolean.');\r\n  }\r\n  logDisabled_ = bool;\r\n  return (bool) ? 'adapter.js logging disabled' :\r\n      'adapter.js logging enabled';\r\n}\r\n\r\n/**\r\n * Disable or enable deprecation warnings\r\n * @param {!boolean} bool set to true to disable warnings.\r\n */\r\nexport function disableWarnings(bool) {\r\n  if (typeof bool !== 'boolean') {\r\n    return new Error('Argument type: ' + typeof bool +\r\n        '. Please use a boolean.');\r\n  }\r\n  deprecationWarnings_ = !bool;\r\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\r\n}\r\n\r\nexport function log() {\r\n  if (typeof window === 'object') {\r\n    if (logDisabled_) {\r\n      return;\r\n    }\r\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\r\n      console.log.apply(console, arguments);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\r\n */\r\nexport function deprecated(oldMethod, newMethod) {\r\n  if (!deprecationWarnings_) {\r\n    return;\r\n  }\r\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\r\n      ' instead.');\r\n}\r\n\r\n/**\r\n * Browser detector.\r\n *\r\n * @return {object} result containing browser and version\r\n *     properties.\r\n */\r\nexport function detectBrowser(window) {\r\n  // Returned result object.\r\n  const result = {browser: null, version: null};\r\n\r\n  // Fail early if it's not a browser\r\n  if (typeof window === 'undefined' || !window.navigator) {\r\n    result.browser = 'Not a browser.';\r\n    return result;\r\n  }\r\n\r\n  const {navigator} = window;\r\n\r\n  if (navigator.mozGetUserMedia) { // Firefox.\r\n    result.browser = 'firefox';\r\n    result.version = extractVersion(navigator.userAgent,\r\n        /Firefox\\/(\\d+)\\./, 1);\r\n  } else if (navigator.webkitGetUserMedia ||\r\n      (window.isSecureContext === false && window.webkitRTCPeerConnection &&\r\n       !window.RTCIceGatherer)) {\r\n    // Chrome, Chromium, Webview, Opera.\r\n    // Version matches Chrome/WebRTC version.\r\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\r\n    // more complicated fallback to webkitRTCPeerConnection.\r\n    result.browser = 'chrome';\r\n    result.version = extractVersion(navigator.userAgent,\r\n        /Chrom(e|ium)\\/(\\d+)\\./, 2);\r\n  } else if (navigator.mediaDevices &&\r\n      navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge.\r\n    result.browser = 'edge';\r\n    result.version = extractVersion(navigator.userAgent,\r\n        /Edge\\/(\\d+).(\\d+)$/, 2);\r\n  } else if (window.RTCPeerConnection &&\r\n      navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\r\n    result.browser = 'safari';\r\n    result.version = extractVersion(navigator.userAgent,\r\n        /AppleWebKit\\/(\\d+)\\./, 1);\r\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver &&\r\n        'currentDirection' in window.RTCRtpTransceiver.prototype;\r\n  } else { // Default fallthrough: not supported.\r\n    result.browser = 'Not a supported browser.';\r\n    return result;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Checks if something is an object.\r\n *\r\n * @param {*} val The something you want to check.\r\n * @return true if val is an object, false otherwise.\r\n */\r\nfunction isObject(val) {\r\n  return Object.prototype.toString.call(val) === '[object Object]';\r\n}\r\n\r\n/**\r\n * Remove all empty objects and undefined values\r\n * from a nested object -- an enhanced and vanilla version\r\n * of Lodash's `compact`.\r\n */\r\nexport function compactObject(data) {\r\n  if (!isObject(data)) {\r\n    return data;\r\n  }\r\n\r\n  return Object.keys(data).reduce(function(accumulator, key) {\r\n    const isObj = isObject(data[key]);\r\n    const value = isObj ? compactObject(data[key]) : data[key];\r\n    const isEmptyObject = isObj && !Object.keys(value).length;\r\n    if (value === undefined || isEmptyObject) {\r\n      return accumulator;\r\n    }\r\n    return Object.assign(accumulator, {[key]: value});\r\n  }, {});\r\n}\r\n\r\n/* iterates the stats graph recursively. */\r\nexport function walkStats(stats, base, resultSet) {\r\n  if (!base || resultSet.has(base.id)) {\r\n    return;\r\n  }\r\n  resultSet.set(base.id, base);\r\n  Object.keys(base).forEach(name => {\r\n    if (name.endsWith('Id')) {\r\n      walkStats(stats, stats.get(base[name]), resultSet);\r\n    } else if (name.endsWith('Ids')) {\r\n      base[name].forEach(id => {\r\n        walkStats(stats, stats.get(id), resultSet);\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n/* filter getStats for a sender/receiver track. */\r\nexport function filterStats(result, track, outbound) {\r\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\r\n  const filteredResult = new Map();\r\n  if (track === null) {\r\n    return filteredResult;\r\n  }\r\n  const trackStats = [];\r\n  result.forEach(value => {\r\n    if (value.type === 'track' &&\r\n        value.trackIdentifier === track.id) {\r\n      trackStats.push(value);\r\n    }\r\n  });\r\n  trackStats.forEach(trackStat => {\r\n    result.forEach(stats => {\r\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\r\n        walkStats(result, stats, filteredResult);\r\n      }\r\n    });\r\n  });\r\n  return filteredResult;\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}